<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../haxcms-elements/haxcms-theme-behavior.html">
<link rel="import" href="../schema-behaviors/schema-behaviors.html">
<link rel="import" href="../simple-colors/simple-colors.html">
<link rel="import" href="../paper-card/paper-card.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../map-menu/map-menu.html">
<link rel="import" href="../iron-pages/iron-pages.html">


<link rel="import" href="odl-haxtheme-home.html">
<link rel="import" href="odl-haxtheme-news.html">
<link rel="import" href="odl-team-feed.html">
<link rel="import" href="odl-topbar.html">
<link rel="import" href="temp-nav.html">
<link rel="import" href="odl-footer.html">
<link rel="import" href="scroll-to-top.html">

<link href="https://fonts.googleapis.com/css?family=Roboto:100"
  rel="stylesheet">

<!--
`odl-haxtheme`
A theme intended as the starting point to fork from and build new themes for HAXCMS
which allows you to build things that just work using JSON Outline Schema as it's "backend"
and then IF hax is around it'll show up :)

@demo demo/index.html

-->
<dom-module id="odl-haxtheme">
  <template>
    <style is="custom-style" include="simple-colors">
     ::slotted(*) {
        font-family: "Roboto", sans-serif;
      }

    </style>
    
    <odl-topbar></odl-topbar>
    <temp-nav></temp-nav>
    <iron-pages selected="[[selectedPage]]">
      <odl-haxtheme-home>
          <div id="slot">
            <slot></slot>
          </div>
      </odl-haxtheme-home>
      <odl-haxtheme-news></odl-haxtheme-news>
      <div>Page 2</div>
      <odl-team-feed></odl-team-feed>
    </iron-pages>
    <scroll-to-top></scroll-to-top>
    <odl-footer></odl-footer>




    
    <map-menu id="menu"></map-menu>



    <!-- <div class="manifest">
      <h2>title: [[manifest.title]]</h2>
      <div>description: [[manifest.description]]</div>
      <div>icon: <iron-icon icon="[[manifest.metadata.icon]]"></iron-icon></div>
      <div>image: <img src$="[[manifest.metadata.image]]" height="200px"
          width="200px" /></div>
    </div> -->
    <div class="activeitem">
      <paper-button id="unset">Unset activeItem</paper-button>
      <div id="contentcontainer">
          <!-- <slot></slot> -->
        </div>
      </div>
    </div>
  </template>
  <script>
    Polymer({
      is: 'odl-haxtheme',
      behaviors: [
        SchemaBehaviors.Schema,
        window.simpleColorsBehaviors,
        HAXCMSBehaviors.Theme,
      ],
      properties: {
          /**
          * The "page" to show (overview or blog post itself).
          */
          selectedPage: {
          type: Number,
          reflectToAttribute: true,
          value: 0,
        },
          /**
         * item in JSON Outline Schema Item format
         */
         activeItem: {
          type: Object,
          notify: true,
        },
        
        // The behavior gives you editMode, activeItem and manifest
        // You can add whatever else you need here
      },
      listeners: {
        'unset.tap': '_unsetTapped',
        'menu.selected': '__menuSelectedItemChanged'
      },
      observers: [
        '__manifestNavigationChanged(manifest.items)'
      ],
      /**
       * Ready life cycle
       */
      ready: function () {
        // required so that HAX is injected when available
        this.setupHAXTheme();
        document.body.addEventListener('json-outline-schema-active-item-changed', this._activeItemEvent.bind(this));
      },
       /**
       * Notice active item changed state
       */
       _activeItemEvent: function (e) {
        // console.log(e.detail);
        if (typeof e.detail.id !== typeof undefined) {
          switch (e.detail.id) {
          case 'home':
          this.selectedPage = 0;
         break;
          case 'news':
          this.selectedPage = 1;
          // Polymer.cmsSiteEditor.requestAvailability(this, this.$.blogpost.$.contentcontainer);
        break;
        case 'team':
          this.selectedPage = 3;
          // whatever
          break;
      }
          window.scrollTo(0, 0);
          this.set('activeItem', e.detail);

        }
        else {
          this.selectedPage = 0;
        }
      },
      /**
       * Detatched life cycle
       */
      detached: function () {
        // this helps with cleaning things up if the theme is changed
        this.setupHAXTheme(false);
        document.body.removeEventListener('json-outline-schema-active-item-changed', this._activeItemEvent.bind(this));
      },
      /**
       * Settings activeItem to nothing will ensure that state goes back to nothing active
       * and then other options appear
       */
      _unsetTapped: function (e) {
        this.fire('json-outline-schema-active-item-changed', {});
      },
      /**
       * Listen for the user to select an item on the menu and change the page
       */
      __menuSelectedItemChanged: function (e) {
        const manifestJOS = this.manifest.items
        const activeItem = manifestJOS.find(item => {
          if (item.id === e.detail) {
            return true
          }
          return false
        })
        this.fire('json-outline-schema-active-item-changed', activeItem);
      },
      /**
       * When the navigation in the manifest changes then rebuild the menu
       */
      __manifestNavigationChanged: function (items) {
        if (typeof items !== 'undefined' && items.length) {
          this.$.menu.setData(items)
        }
      },
    });
  </script>
</dom-module>